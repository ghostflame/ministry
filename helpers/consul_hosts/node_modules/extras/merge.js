
// merge two arrays, return a new one
Array.prototype.merge = function( add, crop ) {

  var ret = [ ];
  crop = !!crop;

  // grab new stuff
  for( var i = 0; i < add.length; i++ ) {
    if( typeof this[i] == 'undefined' ) {
      ret[i] = add[i];
    }
  }

  // iterate across our contents
  for( var i = 0; i < this.length; i++ ) {

    if( typeof add[i] == 'undefined' ) {
      // only keep extra defaults if we we told to
      if( crop == false ) {
        ret[i] = this[i];
      }
      continue;
    }

    // do the types match and are they suitable?
    if( ( this[i].constructor == Object
        && add[i].constructor == Object )
     || ( this[i].constructor == Array
        && add[i].constructor == Array ) ) {
        // same type - recursively call merge
        ret[i] = this[i].merge( add[i], crop );
        continue;
    }

    // other stuff - including incompatible types
    // new wins
    ret[i] = add[i];
  }

  return ret;
};


// new type wins for type setting
Object.prototype.merge = function( add, crop ) {

  var ret = { };
  crop = !!crop;

  // bring in new stuff
  for( var p in add ) {
    if( typeof this[p] == 'undefined' ) {
      ret[p] = add[p];
    }
  }

  // merge old stuff
  for( var p in this ) {

    // never mind inherited stuff
    if( !this.hasOwnProperty( p ) ) { continue; }

    // not present in new - use default
    if( typeof add[p] == 'undefined' ) {
      ret[p] = this[p];
      continue;
    }

    // matching, suitable types merge recursively
    if( ( this[p].constructor == Object
        && add[p].constructor == Object )
     || ( this[p].constructor == Array
        && add[p].constructor == Array ) ) {
      // call the recursive merge
      ret[p] = this[p].merge( add[p], crop );
      continue;
    }

    // for simple types, or incompatible types
    // new wins
    ret[p] = add[p];
  }

  return ret;
};


