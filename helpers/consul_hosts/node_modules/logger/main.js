function Logger( ) {

    var mods = {
        util:       require( 'util' ),
        fs:         require( 'fs' ),
        vm:         require( 'vm' ),
        extras:     require( 'extras' ),
        colors:     require( 'colors' ),
    };
    var slice = Array.prototype.slice;
    var config = {
        flags:      {
            sigset:     false,
            debug:      false,
            objColour:  false,
            lvlColour:  false,
            showEmpty:  false,
        },
        path:       null,
        prefix:     '',
        colour:     'none',
        levels:     [ 'FATAL', 'ERROR', 'WARN', 'NOTICE', 'INFO', 'DEBUG', 'TRACE' ],
        levelStr:   [
            'FATAL'.red.inverse,
            'ERROR'.red,
            'WARN'.yellow,
            'NOTICE'.cyan,
            'INFO'.green,
            'DEBUG'.magenta,
            'TRACE'.white,
        ],
        logLevel:   { },
    };
    var stream = null;
    var logger = this;

    // and this is a property that can get set by delegate
    this.level = 10;


    var openFile = function( ) {

        if( !config.path ) {
            return;
        }

        stream = mods.fs.createWriteStream( config.path,
                    { flags: 'a', encoding: 'utf8', mode: 0644 } );

        stream.on( 'error', function( err ) {
            console.error( 'Logging error: ' + err );
            stream.destroy( );
            stream = null;

            // try again in 2 seconds
            setTimeout( openFile, 2000 );
        });
    };


    // close the file, emit a message to that effect
    var closeFile = function( ) {

        if( stream ) {
            var out = stream;
            out.on( 'close', function( ) {
                process.emit( 'Logger-File-Closed' );
            });
            out.end( );
        }

        stream = null;
    };


    var reopenFile = function( ) {
        closeFile( );
        openFile( );
    };


    var loadFilePath = function( lgr, path ) {

       var retval = null;

        try {
            var dt = mods.fs.readFileSync( path, 'utf8' );
            retval = mods.vm.runInThisContext( 'rv = ' + dt, path );
        } catch( err ) {
            lgr.error( 'Could not load file ' + path + ': ' + err );
        }

        return retval;

    };


    // keep track of a file mtime
    var watchFilePath = function( lgr, path, evt, intv, statEvt ) {

        var state = {
            path:       path,
            fails:      0,
            last:       true,
            timer:      null,
            ms:         0,
            mtime:      new Date( ),
        };

        var checkMtime = function( ) {

            mods.fs.stat( path, function( err, st ) {

                var ms, pr;

                if( err ) {

                    // failure
                    lgr.error( 'Cannot stat file ' + state.path + ': ' + err );

                    // keep track
                    state.fails += 1;
                    state.last   = false;

                } else {

                    // success
                    ms = st.mtime.getTime( );

                    state.fails = 0;
                    state.last  = true;

                    if( state.ms !== 0
                     && state.ms !== ms ) {
                        state.mtime = st.mtime;
                        process.emit( evt, state );
                    }

                    state.ms = ms;
                }

                // are we notifying the result?
                if( statEvt ) {
                    process.emit( statEvt, state );
                }
            });
        };

        // set up a regular check
        state.timer = setInterval( checkMtime, intv || 60000 );

        // do it now to get a timestamp
        checkMtime( );

        // and return the state object
        return state;
    };


    var watchDirPath = function( lgr, path, opts ) {

        var fileHash = { };
        var stat = mods.fs.statSync( path );

        if( !stat.isDirectory( ) ) {
            lgr.error( 'Cannot watchDir on ' + path + ': not a directory' );
            return null;
        }

        // make sure we have sensible options
        opts         = opts         || { };
        opts.evt     = opts.evt     || 'watchDir_' + path;
        opts.intv    = opts.intv    || 60000;
        opts.delEvt  = opts.delEvt  || 'logger_deleted_' + opts.evt;
        opts.statEvt = opts.statEvt || 'logger_stat_' + opts.evt;
        opts.pattern = opts.pattern || null;

        // this is what we do on finding out stat has failed 3 times
        process.on( opts.statEvt, function( state ) {

            if( !( state.path in fileHash ) ) {
                lgr.warn( 'Received statEvt for unknown file ' + state.path );
                return;
            }

            // too many failures?  shut it down
            if( state.fails > 3 ) {

                // say we've deleted a file
                process.emit( opts.delEvt, state );

                clearInterval( state.timer );
                delete fileHash[state.path];

                lgr.info( 'Stopped watching file ' + state.path + ' due to stat errors.' );
            }
        });


        // search the directory for files
        var searchDir = function( ) {

            lgr.debug( 'Searching directory ' + path );

            mods.fs.readdir( path, function( err, files ) {

                var fpath;

                if( err ) {
                    lgr.error( 'Could not readdir ' + path + ': ' + err );
                    return;
                }

                // make a copy of the current hash
                var currPaths = Object.keys( fileHash );
                var currHash  = { };

                for( var i = 0; i < currPaths.length; i++ ) {
                    currHash[currPaths[i]] = true;
                }

                for( var i = 0; i < files.length; i++ ) {
                    if( opts.pattern && ! files[i].match( opts.pattern ) ) {
                        continue;
                    }

                    // make that the full path
                    fpath = path + '/' + files[i];

                    if( fpath in currHash ) {
                        // remove from our copy of the current hash
                        delete currHash[fpath];
                    } else {
                        // this is new - so start watching it
                        fileHash[fpath] = watchFilePath( lgr, fpath, opts.evt, opts.intv, opts.statEvt );

                        // any immediately emit about it
                        process.emit( opts.evt, fileHash[fpath] );
                    }
                }

                // now currHash contains only deprecated files...
                for( var p in currHash ) {
                    if( p in fileHash ) {
                        process.emit( opts.delEvt, fileHash[p] );
                        clearInterval( fileHash[p].timer );
                        delete fileHash[p];
                    }
                }
            });
        };

        // throw an event for 3 times the interval
        setInterval( searchDir, 3 * opts.intv );

        // and do it now
        searchDir( path );

        // right, done.  Here's your tuned options
        return opts;
    };




    var writeMessage = function( msg ) {

        // always prepend the date
        msg = (new Date( )).toMsString( ) + ' ' + msg;

        if( stream ) {
            stream.write( msg + '\n' );

            if( !config.flags.debug ) {
                return;
            }
        }

        console.log( msg );
    };

    var logMessage = function( level, str, msg ) {

        // drop empty messages
        if( !msg.length && !config.flags.showEmpty ) {
            return;
        }

        var out = '[' + str + '] ' + config.prefix + msg;
        writeMessage( out );

        // also send fatals to stderr if we are logging to file
        if( stream && level <= config.logLevel.FATAL ) {
            console.error( out );
        }
    };











    // interface


    this.delegate = function( prefix, obj ) {

        // the parent object
        var that = this;

        obj = obj || { };
        obj.prefix = ( prefix ) ? ( Array.isArray( prefix ) ? prefix : [ prefix ] ) : [ ];

        // inherit from parent
        obj.level  = that.level;

        // set level sets the delegate level
        obj.setLevel = function( level ) {

            level = level.toUpperCase( );

            if( !( level in config.logLevel ) ) {
                level = 'INFO';
            }

            this.level = config.logLevel[level];

            return this;
        };


        var makeFunction = function( level ) {

            var l = config.logLevel[level];
            var s = ( config.lvlColour ) ? config.levelStr[l] : level;
            
            return function( ) {

                // do nothing if the level is wrong
                if( l > this.level ) {
                    return;
                }

                var args = slice.apply( arguments );
                var msg  = '';
                var arg;

                while( args.length > 1 ) {
                    arg = args.shift( );
                    if( Array.isArray( arg ) ) {
                        arg = arg.join( '] [' );
                    }
                    msg += '[' + arg + '] ';
                }

                logMessage( l, s, msg + args[0] );
            };
        };


        // binds the parent calls
        var boundFunction = function( fn ) {

            if( prefix ) {
                return fn.bind( obj, prefix );
            }

            return fn.bind( obj );
        };

        var methods = {
            'trace':    'TRACE',
            'debug':    'DEBUG',
            'notice':   'NOTICE',
            'info':     'INFO',
            'warn':     'WARN',
            'error':    'ERROR',
            'err':      'ERROR',    // legacy support
            'fatal':    'FATAL',
        };

        for( var m in methods ) {
            obj[m] = boundFunction( makeFunction( methods[m] ) );
        }

        // die is special
        // expects ( msg, exitValue )
        var die = function( ) {

            var args  = slice.apply( arguments );
            var exval = 1;

            if( typeof args[args.length - 1] === 'number' ) {
                exval = args.pop( ) || 1;
            }

            this.fatal.apply( null, args );
            closeFile( );
            process.exit( exval || 1 );
        };

        // showMe is special too
        // debug with an extra
        var showMe = function( ) {

            if( config.logLevel['DEBUG'] > this.level ) {
                return;
            }

            var depth = 4;
            var obj   = { };

            var args  = slice.apply( arguments );
            var last  = args.pop( );
            var tlast = typeof last;

            if( typeof last === 'number' ) {
                depth = last;
                obj   = args.pop( ) || { };
            } else {
                obj   = last || { };
            }

            var msg = args.pop( ) + ':\n' + mods.util.inspect( obj, {
                showHidden:     true,
                colors:         config.objColour,
                depth:          depth,
                customInspect:  true,
            } );


            args.push( msg );

            this.debug.apply( null, args );
        };

        obj.die    = boundFunction( die );
        obj.showMe = boundFunction( showMe );

        // bring some utilities across for convenience, but they
        // remain bound to the original logger
        obj.loadFile  = logger.loadFile.bind( logger );
        obj.setFile   = logger.setFile.bind( logger );
        obj.setColour = logger.setColour.bind( logger );
        obj.watchFile = logger.watchFile.bind( logger );
        obj.watchDir  = logger.watchDir.bind( logger );
        obj.exit      = logger.exit.bind( logger );

        // except for setColour
        obj.setColour = logger.setColour;

        // and allow multiple delegations
        if( !obj.hasOwnProperty( 'delegate' ) ) {

            obj.delegate = function( prefix ) {

                if( !Array.isArray( prefix ) ) {
                    prefix = [ prefix ];
                }

                return that.delegate( obj.prefix.concat( prefix ) );
            };
        };

        return obj;
    };




    this.setFile = function( path ) {

        if( path ) {
            if( !config.flags.sigset ) {
                process.addListener( 'SIGHUP', reopenFile );
                config.flags.sigset = true;
            }
        } else {
            if( config.flags.sigset ) {
                process.removeListener( 'SIGHUP', reopenFile );
                config.flags.sigset = true;
            }
        }

        config.path = path;
        reopenFile( );

        return this;
    };


    this.setColour = function( val ) {

        var changed = false;
        val = val.toLowerCase( );

        switch( val ) {
            case 'none':
                if( config.lvlColour || config.objColour ) {
                    changed = true;
                }
                config.lvlColour = false;
                config.objColour = false;
                break;
            case 'debug':
                if( config.lvlColour || !config.objColour ) {
                    changed = true;
                }
                config.lvlColour = false;
                config.objColour = true;
                break;
            case 'all':
                if( !config.lvlColour || !config.objColour ) {
                    changed = true;
                }
                config.lvlColour = true;
                config.objColour = true;
                break;
        }

        // remake functions
        if( changed ) {
            this.delegate( null, this );
        }

        return this;
    };



    // a weird utility - load a js file as an object
    this.loadFile = function( path ) {
        return loadFilePath( this, path );
    };

    // another weird utility - watch a file
    this.watchFile = function( path, evt, intv, statEvt ) {
        return watchFilePath( this, path, evt, intv, statEvt );
    };

    // and watch a directory
    this.watchDir = function( path, opts ) {
        return watchDirPath( this, path, opts );
    };


    // expose a way to re-open the filehandle
    this.reopen = function( ) {
        return reopenFile( );
    };

    this.showEmpty = function( show ) {
        config.flags.showEmpty = !!show;
    };

    this.exit = function( exval ) {

        if( stream ) {
            stream.on( 'close', function( ) {
                process.exit( exval );
            });
            stream.end( );
        } else {
            process.exit( exval );
        }
    };


    var logOpt = function( opts, name ) {

        if( name in opts ) {
            return opts[name];
        }

        var envName = 'LOGGING_' + name.toUpperCase( );

        if( envName in process.env ) {
            return process.env[envName]
        }

        return null;
    };

    // parse an options structure
    this.loggingArgs = function( opts ) {

        var o;

        // send back what we expect to see
        // suitable for dropping into cli args
        if( !opts ) {
            return [
                [ 'D', 'debug',         'Turn on debug output' ],
                [  '', 'verbose',       'Turn on verbose logging' ],
                [  '', 'trace',         'Turn on trace logging' ],
                [  '', 'quiet',         'Turn on quiet logging' ],
                [  '', 'silent',        'Turn off almost all logging' ],
                [  '', 'colour-all',    'Turn on all colour' ],
                [  '', 'colour-debug',  'Turn on colour in showMe output' ],
                [  '', 'no-colour',     'Turn off all colour' ],
                [ 'F', 'logfile=ARG',   'Set log file (default is stdout)' ],
            ];
        }

        if( logOpt( opts, 'trace' ) ) {
            this.setLevel( 'TRACE' );
            config.flags.debug = true;
            config.flags.showEmpty = true;
        } else if( logOpt( opts, 'debug' ) ) {
            this.setLevel( 'DEBUG' );
            config.flags.debug = true;
        } else if( logOpt( opts, 'verbose' ) ) {
            this.setLevel( 'INFO' );
        } else if( logOpt( opts, 'quiet' ) ) {
            this.setLevel( 'WARN' );
        } else if( logOpt( opts, 'silent' ) ) {
            this.setLevel( 'FATAL' );
        }

        // colour setting
        if( logOpt( opts, 'no-colour' ) ) {
            this.setColour( 'none' );
        } else if( logOpt( opts, 'colour-all' ) ) {
            this.setColour( 'all' );
        } else if( logOpt( opts, 'colour-debug' ) ) {
            this.setColour( 'debug' );
        }

        // and logfile setting
        if( ( o = logOpt( opts, 'logfile' ) ) ) {
            this.setFile( o );
        }

        return this;
    };


    // startup

    // create the reverse lookup for log levels
    for( var i = 0; i < config.levels.length; i++ ) {
        config.logLevel[config.levels[i]] = i;
    }

    // and bring in the dates extras
    mods.extras.getDates( );

    // then give ourselves those logging functions
    this.delegate( null, this );

    // and the default log level
    this.setLevel( 'NOTICE' );
}

module.exports = Logger;
