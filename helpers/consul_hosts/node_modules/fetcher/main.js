function Fetcher( logger ) {

    var mods   = {
        http:       require( 'http' ),
        https:      require( 'https' ),
        zlib:       require( 'zlib' ),
        logger:     require( 'logger' ),
    };

    var config = {
        guess:      false,
        rpcId:      0,
        okCodes:    [ 200, 301, 302 ],
        always:     false,

        jsType:     /(text|application)\/json/i,
        jsData:     /^(:?\{.*\}|\[.*\])$/,
    };

    logger = logger || new mods.logger( );



    var isJson = function( type, buf ) {

        if( config.jsType.test( type )
         || ( config.guess
           && config.jsData.test( buf.trim( ) ) ) ) {
            return true;
        }

        return false;
    };


    // common work on all requests - set up options
    var prepOptions = function( opts, close ) {

        if( !opts.host && !opts.socketPath ) {
            logger.warn( 'Invalid options structure - no host or socket' );
            return null;
        }

        if( !opts.path ) {
            opts.path = '/';
        }

        if( !opts.headers ) {
            opts.headers = { };
        }

        opts.headers['Connection'] = ( close ) ? 'close' : 'keep-alive';

        // default user agent is nodejs fetcher
        if( !opts.headers['User-Agent'] ) {
            opts.headers['User-Agent'] = 'NodeJS fetcher module v0.2';
        }

        // are we doing timing?
        if( opts.timer ) {
            opts.start = (new Date( )).getTime( );
        }

        // force servername to be obeyed
        if( opts.servername ) {
            opts.agent = false;
        }

        // prefer to accept self-signed unless specified
        opts.rejectUnauthorized = !! opts.fussy;

        // anti-smuggling
        opts.path = opts.path.split( /[\r\n\t]/ )[0];

        // return a destination string
        if( opts.host ) {
            if( opts.port ) {
                return opts.host + ':' + opts.port + opts.path;
            }
            return opts.host + opts.path;
        }

        return opts.socketPath + opts.path;
    };


    var getHeader = function( res, name ) {

        if( res.headers[name] ) {
            return res.headers[name];
        }
        name = name.toLowerCase( );
        if( res.headers[name] ) {
            return res.headers[name];
        }
        return '';
    };


    // try parsing as a json response, then call the callback
    var parseAndCall = function( cb, opts, res, type, enc, buf ) {

        // decompress first
        if( enc == 'gzip' ) {

            mods.zlib.gunzip( buf, function( err, text ) {
                // bail out on error
                if( err ) {
                    if( !opts.quiet ) {
                        logger.error( 'bad gzipped content: ' + err );
                    }
                    return;
                }
                // call ourself with no encoding
                parseAndCall( cb, opts, res, type, '', text.toString( ) );
            });

            // done - let the callback re-engage us
            return true;
        }


        if( !isJson( type, buf ) ) {
            cb( opts, res, buf );
            return true;
        }

        var json = null;

        try {
            json = JSON.parse( buf );
        } catch( err ) {
            if( !opts.quiet ) {
                logger.error( 'could not decode json: ' + err.message );
                logger.debug( 'Bad JSON: ' + buf );
            }
            if( config.always ) {
                cb( opts, res, buf );
            }
            return false;
        }

        cb( opts, res, json );
        return true;
    };


    // handle server response
    var responseHandler = function( opts, dest, callback, res ) {

        if( config.okCodes.indexOf( res.statusCode ) < 0 ) {
            if( !opts.quiet ) {
                logger.error( 'bad status code (' + res.statusCode + ') for: ' + dest );
                logger.showMe( 'response opts', opts );
            }
            if( !config.always ) {
                return false;
            }
        }

        res.on( 'error', function( err ) {
            if( !opts.quiet ) {
                logger.error( 'bad response from ' + dest + '  : ' + err.message );
            }
            if( !config.always ) {
                return false;
            }
        });

        // we want some stuff to decide how to proceed
        var cty = getHeader( res, 'Content-Type' );
        var enc = getHeader( res, 'Content-Encoding' );
        var len = getHeader( res, 'Content-Length' );
        var buf = '';
        var bl  = 0;

        // finish, maybe time it
        res.on( 'end', function( ) {

            // are we doing timing?
            if( opts.timer ) {
                opts.finish = (new Date( )).getTime( );
            }

            var resData = {
                code:     res.statusCode,
                headers:  res.headers,
            };

            return parseAndCall( callback, opts, resData, cty, enc, buf );
        });


        if( enc == 'gzip' ) {

            // default to an 8M buffer when we have no Content-Length
            var bsz = parseInt( len ) || 8388608;

            buf = new Buffer( bsz );

            res.on( 'data', function( chunk ) {

                if( ( bl + chunk.length ) > bsz ) {
                    if( !opts.quiet ) {
                        logger.warn( 'Aborting gzip data copy - out of buffer space.' );
                        return;
                    }
                }

                chunk.copy( buf, bl );
                bl += chunk.length;
            });

        } else {
            res.setEncoding( 'utf8' );

            res.on( 'data', function( chunk ) {
                buf += chunk.toString( );
            });
        }
    };



    var getData = function( mod, options, callback ) {

        var dest;

        if( !( dest = prepOptions( options, true ) ) ) {
            return false;
        }

        // handler shared with post
        var req = mod.get( options, function( res ) {
            responseHandler( options, dest, callback, res );
        });

        // allow a specified timeout
        if( options.timeout ) {
            req.setTimeout( options.timeout );
        }

        req.on( 'error', function( e ) {
            if( !options.quiet ) {
                logger.error( 'unknown request error for: ' + dest + ': ' + e );
            }
            return false;
        });
    };


    // utility for tweets
    var breakDataOnRegex = function( data, sep ) {

        var list  = data.split( sep );
        var spare = '';

        if( data.substring( 0 - sep.length ) != sep ) {
            spare = list.pop( );
        }

        return { vals: list, leftover: spare };
    }


    // designed to get stream data, as per twitter
    var getStream = function( mod, options, separator, cb_data, cb_end ) {

        var dest;

        if( !( dest = prepOptions( options, true ) ) ) {
            return false;
        }

        var req = mod.get( options, function( res ) {

            if( config.okCodes.indexOf( res.statusCode ) < 0 ) {
                if( !options.quiet ) {
                    logger.error( 'bad status code (' + res.statusCode + ') for: ' + dest );
                }
                return false;
            }
            res.setEncoding( 'utf8' );

            var resData = {
                code:     res.statusCode,
                headers:  res.headers,
            };

            var cty = getHeader( res, 'Content-Type' );
            var buf = '';
            var ret;

            res.on( 'data', function( chunk ) {

                buf += chunk.toString( );

                if( !buf.trim().length ) {
                    return
                }

                // break it into chunks based on the separator
                ret = breakDataOnRegex( buf, separator );

                // keep the unused section
                buf = ret.leftover;

                // pass the rest to the callback provided
                for( var i = 0; i < ret.vals.length; i++ ) {

                    var v = ret.vals[i];
                    if( !v.length ) {
                        continue;
                    }

                    if( !parseAndCall( cb_data, options, resData, cty, '', v ) ) {
                        return false;
                    }
                }
            });

            res.on( 'error', function( err ) {
                if( !options.quiet ) {
                    logger.error( 'bad response from ' + dest + '  : ' + err.message );
                }
                return false;
            });

            res.on( 'end', function( ) {
                if( cb_end ) {
                    cb_end( options, resData, '' );
                }
            });
        });

        // allow a specified timeout
        if( options.timeout ) {
            req.setTimeout( options.timeout );
        }

        req.on( 'error', function( e ) {
            if( !options.quiet ) {
                logger.error( 'unknown request error for: ' + dest + ': ' + e );
            }
            return false;
        });
    };


    var postData = function( mod, options, data, callback ) {

        var dest;

        options.method = 'POST';

        if( !( dest = prepOptions( options, true ) ) ) {
            return false;
        }

        // same handler as get
        var req = mod.request( options, function( res ) {
            responseHandler( options, dest, callback, res );
        });

        // allow a specified timeout
        if( options.timeout ) {
            req.setTimeout( options.timeout );
        }

        req.on( 'error', function( e ) {
            if( !options.quiet ) {
                logger.error( 'unknown request error for: ' + dest + ': ' + e );
            }
            return false;
        });

        var str = '';
        var hdr = '';

        if( options.dataType ) {
            switch( options.dataType ) {
                case 'json':
                    str = JSON.stringify( data );
                    hdr = 'application/json; charset=utf-8';
                    break;
                case 'form':
                    for( var p in data ) {
                        if( str.length ) {
                            str += '&';
                        }
                        str += p + '=' + encodeURIComponent( data[p] );
                    }
                    hdr = 'application/x-www-form-urlencoded; charset=utf-8';
                    break;
            }
        } else if( typeof data != 'string' ) {
            str = JSON.stringify( data );
            hdr = 'application/json; charset=utf-8';
        } else {
            str = data;
            hdr = 'text/plain; charset=utf-8';
        }

        if( hdr.length ) {
            req.setHeader( 'Content-Type', hdr );
        }

        if( str.length ) {
            req.setHeader( 'Content-Length', str.length );
            req.write( str, 'utf8' );
        }

        req.end( );
    };


    // do a json RPC2 call
    var jsonRPC = function( mod, options, method, params, callback ) {

        if( typeof method != 'string' || !method.length ) {
            logger.error( 'Invalid method' );
            return false;
        }

        var id  = config.rpcId++;

        var req = {
            jsonrpc:    '2.0',
            id:         id,
            method:     method,
            params:     ( ( Array.isArray( params ) ) ? params : [ params ] ),
        };

        var rpcRet = function( opts, res, data ) {

            if( data.error ) {
                logger.error( 'Error received in JSON rpc response: ' + data.error.code + ' - ' + data.error.message );
                if( config.always ) {
                    callback( opts, res, data );
                }
                return;
            }
            if( data.id != id ) {
                logger.error( 'Incorrect ID in JSON rpc response: ' + data.id + ' != ' + id );
                if( config.always ) {
                    callback( opts, res, data );
                }
                return;
            }

            // give the caller the method back
            opts.method = method;

            callback( opts, res, data.result );
        };

        return postData( mod, options, req, rpcRet );
    };


    // the main callable fns
    this.get = function( options, callback ) {
        getData( mods.http, options, callback );
    };

    this.getSsl = function( options, callback ) {
        getData( mods.https, options, callback );
    };

    this.stream = function( options, cb_data, cb_end ) {
        getStream( mods.http, options, cb_data, cb_end );
    };

    this.streamSsl = function( options, cb_data, cb_end ) {
        getStream( mods.https, options, cb_data, cb_end );
    };

    this.post = function( options, data, callback ) {
        postData( mods.http, options, data, callback );
    };

    this.postSsl = function( options, data, callback ) {
        postData( mods.https, options, data, callback );
    };

    this.json2 = function( options, method, params, callback ) {
        jsonRPC( mods.http, options, method, params, callback );
    };

    this.json2Ssl = function( options, method, params, callback ) {
        jsonRPC( mods.https, options, method, params, callback );
    }

    // setup fns
    this.setGuessJson = function( doGuess ) {
        config.guess = !! doGuess;
    };

    // set all the ok codes
    this.setOkCodes = function( arr ) {
        config.okCodes = arr.sort( ) || [ 200, 301, 302 ];
    };

    // show the codes
    this.getOkCodes = function( ) {
        return config.okCodes;
    };

    // always call back
    this.alwaysCallback = function( doCall ) {
        config.always = !! doCall;
    };

    // allow self-signed certs?
    this.allowUnauthorized = function( allow ) {
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = ( !!allow ) ? "0" : "1";
    };

    // turn on/off a ok code
    this.setCodeOk = function( code, ok ) {
        if( ok ) {
            if( config.okCodes.indexOf( code ) < 0 ) {
                config.okCodes.push( code );
                config.okCodes = config.okCodes.sort( );
            }
        } else {
            var k = [ ];
            for( var i = 0; i < config.okCodes.length; i++ ) {
                if( config.okCodes[i] != code ) {
                    k.push( config.okCodes[i] );
                }
            }
            config.okCodes = k.sort( );
        }
    };
}

module.exports = Fetcher;
