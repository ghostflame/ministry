#  The Ministry of Statistics, carbon-copy basic config

#  The config file assumes a basic format of
#  variable = value

#  Leading and trailing whitespace are trimmed, as is whitespace around the =
#  sign.  If no value is presented, a value of 1 is assumed, allowing bare
#  values to toggle on behaviour.

#  Further files can be read in, using the mechanism of
#  include = <file path>

#  The current section context is preserved and included files are read in
#  before continuing with the previous file.  Circular inclusion loops are
#  detected, and moaned about.




[Main]
#  Basedir is used to chdir to and forms the path for any relative filenames
#basedir = /

#  Pidfile can be overridden on the command line, and the init script does do
#  that!
#pidfile = /var/run/ministry/carbon-copy.pid

#  The tick_msec value is used by an internal thread to mark time, and it
#  also helps define the responsiveness of ministry to shutdown
#tick_msec = 20

#  By default, ministry alters its nofile and nproc limits to the current
#  hard limit, but these can be set lower if desired.
#limits.procs = 4096
#limits.files = 4096


[Logging]
#  Log level is one of debug info notice warn err fatal
#  Either notice or info is recommended
#level = info

#  Logging is buffered up until the file is opened successfully.  If you are
#  Using logrotate, a pkill -HUP ministry will cause the file to be closed
#  and reopened
#file = /var/log/ministry/carbon-copy.log

#  When the log file is reopened after log rotation (a HUP signal causes the
#  file handle to be closed and opened) the logger writes a line to say that
#  the log file was re-opened.  This means it will always be a non-zero file
#  size, meaning logrotate notifempty will not trigger.  This is turned on by
#  default, so set to zero if you wish to disable this line.
#notify 1


[Memory]
#  This is the direct control of the memory management code within carbon-copy.
#  Carbon-copy eschews a lot of malloc and free in favour of keeping structures
#  and re-using them.  This gives us some tuning parameters and avoids long-
#  term fragmentation issues.

#  Carbon-copy keeps an eye on its overall RSS, and will exit if it uses too
#  much.  The default is 10GB
#max_mb = 10240

#  The max_mb value is also expressible as max KB if you want more precise
#  control.  Don't use both - last one wins
#max_kb = 10485760

#  The interval of memory checking is configurable as well - this is how
#  many MSEC ministry waits in betweeen RSS checks
#interval = 5000




#  Each of ministry's memory-controlled types is pre-allocated in blocks
#  which are made into the 'free list' of structs of that type.  They all
#  have ->next elements first, and that's how it works.  So each can be
#  pre-allocated in configurable blocks.  Powers of two please.  Future
#  releases might force this by changing it to require the power of two to
#  use, not the resulting number (eg 128 might become 7)

#  Host structures are for controlling a connected source of data
#hosts.block = 128

#  Iobufs are used for sending data on to targets, and receiving from hosts
#iobufs.block = 128

#  Iolist is used to manage sending one buf to multiple targets
#iolist.block = 512




[Network]

#  Network timeout sets how long a source connection has to be silent for
#  before we consider it dead and close the connection.  Don't set this too
#  low or clients will keep having to reconnect.
#  This value is in SECONDS
#timeout = 3600

#  Carbon-copy does not write directly to network when it relays metrics, to
#  prevent that having to cope with the vaguaries of networks.  It writes
#  iobufs instead, lumps of outbound data, and io happens async after a time.
#  The io threads associated with each target wake up after so long and send
#  any outstanding data.  If you have a large amount of data you might want
#  to tune this down, but it chews some cpu if it's too fast.  This is
#  configured in MSEC
#io_msec = 500

#  The maximum number of waiting buffers on a target is not done with a view
#  to how much each one holds - 100 buffers with 10 bytes in each is still
#  100 buffers.  Tune this up if data is going missing, but it can result in
#  significant memory use if a target is down.
#max_waiting = 1024

#  Carbon-copy will attempt to reconnect to a down target every so often, and
#  that is configured in MSEC
#reconn_msec = 5000

#  Carbon-copy listens for UDP packets if configured to do so, but by default
#  recv() just waits forever.  Thus we set a receive timeout value and loop
#  around in quiet times.  This value affects how responsive carbon-copy is to
#  shutdown.  You shouldn't need to change it.  It is in SECONDS.
#rcv_tmout = 3



