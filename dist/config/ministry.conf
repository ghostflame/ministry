## The Ministry of Statistics, basic config

#  The config assumes a basic format of
#  variable = value

#  Leading and trailing whitespace are trimmed, as is whitespace around the =
#  sign.  If no value is presented, a value of 1 is assumed, allowing bare
#  values to toggle on behaviour.


## Including Files

#  Further source can be read in, using the mechanism of
#  include = [?]<file path|url> <args>

#  The current section context is preserved and included files are read in
#  before continuing with the previous file.  Circular inclusion loops are
#  detected, and moaned about.

#  Arguments passed into an include can be accessed in the included file as
#  %1%, %2%, ...  Circular inclusion detection accounts for these arguments.
#  This is designed to permit the trivial creation of complex config, (though
#  mainly this is used in ministry-test) by including a single config file
#  multiple times with different arguments

#  If the target path|url begins with a ? then it is considered optional -
#  if it does not exist, or cannot be read or fetched, then a warning is
#  issued by processing continues.  Ministry will stil error out if it is
#  accessible but invalid.


## Foreach

#  Ministry includes an interator mechanism, which will repeat the following
#  line with each value it iterates over.  It takes two forms

#foreach <word> <word> ...

#  This form will call the next line for each of the words passed in.

#foreach <lower> - <upper> [<step>]

#  This form will count from integer lower up to and including upper, using
#  step to increment (step defaults to 1).  Eg  "10 - 20 2" would supply each
#  of 10, 12, 14, 16, 18, 20.

#  Typical usage is in ministry-test, and the typical next line is an include,
#  but it works for ministry as well.



## Config File Sections

[Main]
#  Basedir is used to chdir to and forms the path for any relative filenames
#baseDir = /

#  Pidfile can be overridden on the command line, and the init script does do
#  that!
#pidFile = /var/run/ministry/ministry.pid

#  The tick_msec value is used by an internal thread to mark time, and it
#  also helps define the responsiveness of ministry to shutdown
#tickMsec = 20

#  By default, ministry alters its nofile and nproc limits to the current
#  hard limit, but these can be set lower if desired.
#limits.procs = 4096
#limits.files = 4096

#  Normally ministry will remain connected to the initiating terminal, to
#  support such run environments as supervisord.  However, either via config
#  or a command-line option, ministry can background itself with the daemon()
#  system call, disconnecting from the terminal.
#daemon = 0


[Logging]
#  Ministry logs separately for HTTP requests.  There are two blocks of log
#  config, one for main log, one for http log.  See the note around unified
#  logging.

#  If a block specifier is absent, it is equivalent to main.

#  Log level is one of: debug info notice warn err fatal
#  Either notice or info is recommended
#main.level = info

#  Logging is buffered up until the file is opened successfully.  If you are
#  Using logrotate, a pkill -HUP ministry will cause the file to be closed
#  and reopened.

#  Ministry can log to syslog, and the special filename 'syslog' will cause
#  this behaviour.  By default, however, ministry logs to stdout, to make it
#  easier to use in containers
#main.file = -


#  Log level for HTTP
#http.level = info

#  Filename also defaults to stdout
#http.file = -


#  Ministry can merge the structures for main and http logging (it actually
#  ignores the config for http) to simplify the behaviour.  The log files are
#  unified by default, for backwards compatibility
#unified = 1


#  When the log file is reopened after log rotation (a HUP signal causes the
#  file handle to be closed and opened) the logger writes a line to say that
#  the log file was re-opened.  This means it will always be a non-zero file
#  size, meaning logrotate notifempty will not trigger.  This is turned on by
#  default, so set to zero if you wish to disable this line.
#notify = 1

#  Some syslog setups print the syslog level; some do not.  So the writing of
#  the log level in the message can be controlled.  It is on by default.
#writeLevel = 1

#  When using syslog, Ministry defaults to LOG_LOCAL4 facility and identifier
#  'ministry'.  These can be set (though have no effect unless syslog output
#  is selected.
#facility = LOG_LOCAL4
#identifier = ministry


[Memory]
#  This is the direct control of the memory management code within ministry.
#  Ministry eschews a lot of malloc and free in favour of keeping structures
#  and re-using them.  This gives us some tuning parameters and avoids long-
#  term fragmentation issues.

#  Ministry keeps an eye on its overall RSS, and will exit if it uses too
#  much.  This is because it keeps structures in memory, up to about 6k, for
#  each metric path it's ever seen.  While it does garbage collect paths that
#  have not seen metrics in a a while, this can take an hour or so with
#  default settings, so it also has more short term protection against being
#  flooded with one-time paths.  The default is 10GB
#maxMB = 10240

#  The maxMb value is also expressible as max KB if you want more precise
#  control.  Don't use both - last one wins
#maxKB = 10485760

#  The interval of memory checking is configurable as well - this is how
#  many MSEC ministry waits in betweeen RSS checks
#interval = 5000

#  The memory checking routine can be disabled, but is on by default
#doChecks = 1

#  Ministry can pre-allocate busy memmory types to try and avoid the rather
#  expensive brk() call to allocate more space for them happening within a
#  receive/process cycle.  It looks for the free count of a type of object
#  falling below about a third of its allocation block size and pre-emptively
#  allocates some more.  If your installation is subject to very rapid onset
#  of load, like in-rush load tests of the monitored estate, this can be
#  tuned lower.  Value is in MSEC.
#prealloc = 50



#  Each of ministry's memory-controlled types is pre-allocated in blocks
#  which are made into the 'free list' of structs of that type.  They all
#  have ->next elements first, and that's how it works.  So each can be
#  pre-allocated in configurable blocks.  Powers of two please.  Future
#  releases might force this by changing it to require the power of two to
#  use, not the resulting number (eg 128 might become 7)

#  Iobufs are used for sending data on to targets, and receiving from hosts
#iobufs.block = 128

#  Iobps (IO buf pointers) is used to manage sending one buf to multiple
#  targets
#iobps.block = 512

#  Htreqs are http request objects
#htreqs.block = 128

#  Host structures are for controlling a connected source of data
#hosts.block = 128

#  Dhash is the metric data structure
#dhash.block = 512

#  Points is a struct containing multiple (float) data points
#points.block = 512

#  Tokens are used to verify senders
#tokens.block = 128

#  Predictors are used on metrics where prediction is enabled
#preds.block = 128

#  History is used on metrics with prediction is enabled
#histy.block = 128

#  Metrics objects are used in fetching /metrics sources
#metry.block = 128


[Http]
#  Ministry uses libmicrohttpd to embed a webserver.  It uses it for a
#  variety of tasks - issuing tokens, controlling targets realtime, offering
#  stats and status.

#  Libmicrohttpd understands HTTPS and can manage ciphers and certificates,
#  so a little config is provided to govern that.  Certificates provide one
#  of the few breaks to ministry's lights-out philosophy, in that if a cert
#  requires a password and you do not wish to store it anywhere in config,
#  ministry can interactively prompt the user on the command-line for the
#  password.

#  Which port ministry listens on is specified for http and https, and which
#  is in use is determined by whether https is enabled.
#port = 9080

#  Ministry can bind either to a specific IP address or to all interfaces
#bind = 0.0.0.0

#  The entire webserver can be enabled or disabled.  It is off by default.
#enable = 0


#  Ministry exposes libmicrohttpd's controls on maximum connections per
#  IP, maximum overall and connection timeouts.
#conns.max = 256
#conns.maxPerIP = 64

#  The timeout is in seconds
#conns.timeout = 10


#  Control of TLS is around certificates and ciphers.  Ministry uses the
#  facilities of libmicrohttpd to handle this.

#  Determines whether TLS is enabled
#tls.enable = 0

#  The TLS port is not the same as the non-TLS port normally, but there is
#  no problem setting them to be the same.  Whether TLS is enabled or not
#  determines which port Ministry uses.
#tls.port = 9443

#  Certificate and key files are relative to the basedir unless they begin
#  with a /
#tls.certFile =
#tls.keyFile =

#  If a password is needed for the keyfile, it should be provided in config
#  or interactively on startup (ministry can prompt for it if required -
#  this is set either by passing the -K flag, or configuring the password
#  as the special value "-".  The special value "null" will keep the
#  password unset (it is provided as a reminder for the admin that there is
#  no password set on the key).
#tls.keyPass =


#  Ministry sets a TLS priorities string (see
#  https://gnutls.org/manual/html_node/Priority-Strings.html).  This allows
#  control of ciphers and protocols for TLS.  The default enabled TLSv1.3,
#  TLSv1.2, and only 256-bit ciphers from certain suites.  Change this if
#  you need to support clients with older TLS libraries.  At some point in
#  the future, Ministry will remove support for TLSv1.2.
#tls.priority = "SECURE256:!VERS-TLS1.1:!VERS-TLS1.0:!VERS-SSL3.0:%SAFE_RENEGOTIATION"

[Pmet]
#  Ministry has a metrics endpoint on /metrics, but it is off by default.
#  It has several distinct sources of data which can be turned off if
#  desired.

#  Ministry pregenerates the metrics, rather than on-demand, to provide
#  consistent data to multiple prometheuses.  It puts timestamps with its
#  metrics.

#  Enable or disable metrics
#enable = 0

#  The default generation period is timed to match the default stats period,
#  ie 10 seconds.  Running it more frequently will cause some repeated stats.
#  It has an offset from the period of 25% of the period, to make it more likely
#  that it will neatly capture the stats run data.  If the stats takes more than
#  25% of their period to generate, that will affect the timeliness of metrics
#  numbers (and perhaps result in repeats).  Though equally, if stats is taking
#  more than 25% of the time, that is, separately, cause for concern.
#period = 10000

#  It is possible to disable some of the sources.  The current ones are:
#  shared, stats, targets
#  None are disabled by default.
#disable = <shared, stats or targets>


[Gc]
#  Ministry's GC is very limited - it recycles old DHASH structures for paths
#  that appear to have gone inactive.  This prevents us keeping old paths
#  forever (or until a restart).  This will not make graphite/coal/influx
#  tidy them up!   What happens is that every time stats are processes, if a
#  path has no values, it's 'empty' counter is incremented.  It it reaches a
#  threshold then the next GC run will make it unusable, and then the one
#  after will reap it and free it.  If you are extending ministry yourself,
#  beware - ministry does not 'have GC'.  It's only for DHASH structures.

#  Gc is on by default, but can be disabled.
#enable = 1

#  The threshold of how many stats passes must find a structure empty is what
#  can be configured, but the default of 8640 (so with a 10-second report
#  interval, that's a day) should do you fine.  Tweak if if you tweak the
#  report interval.
#gcThresh = 8640

#  Ministry expects gauges to be reported less frequently, so has a separate
#  gauge gc threshold.  It behaves the same as the stats/adder limit
#gcGaugeThresh = 25960



[Iplist]
#  Ministry has the concept of IP lists - a list of whitelist/blacklist
#  entries used to decide if an IP address matches for a given purpose.
#  Rather than have them at the site of the calling config - for example,
#  prefixing, or accept filtering, Ministry has named IP lists, which are
#  then referenced by these calling configs.  There is no limit to the
#  number of them.

#  Lists need a unique name, a hashsize (individual IPs are hashed, but
#  networks done with masking).  They can be logged out during startup if
#  marked as verbose.  They can default to match or miss.  They can be
#  individually enabled/disabled.

#  IP lists can take a parameter after the IP spec, which is recorded as
#  text.  This is the way they are used for prefixing, where the text
#  after a given entry is used as the prefix.  The other use case is for
#  filtering connections; any text after the spec will be ignored.

#  Each IP list is configured with a set of entries, terminating in a
#  'done' statement.  Ordering of list entries is preserved, and they are
#  checked in that order.  So, if there are three entries:

#  match:  10.0.1.0/24
#  miss:   10.0.0.0/22
#  match:  10.0.0.0/16

#  Then 10.0.1.2 will match, 10.0.0.2 will not, but 10.0.20.2 will.

#  An example filter list looks like this:
#name = Approved Hosts
#enable = 1
#default = 0
#verbose = 0
#hashsize = 2003
#match = 10.32.0.0/23
#match = 10.32.2.0/23
#match = 10.32.7.161
#match = 10.32.7.162
#match = 10.32.7.163
#miss = 10.32.0.0/18
#match = 10.32.0.0/16
#done

#  IP Lists are also used for prefixing.

#  Arguments are of the form of "<specifier> <prefix>." with a trailing dot.
#  Prefix sanitisation is limited to making sure there is a trailing dot.
#  A different line parser function is invoked if a host matches for prefix
#  prepending, which copies the string into a buffer before working on it.
#  This places different limits on the size of paths allowed, and at present
#  it is hardcoded to prefix + path maxing out at 8191 bytes.  Prefixes
#  themselves are capped at 1023 bytes.  Excess whitespace before the prefix
#  is ignored, allowing lined-up formatting

#  An example prefixing list looks like this:
#name = Prefixes
#enable = 1
#default = 0
#hashsize = 2003
#entry = 10.32.0.9       hosts.pentesting.
#entry = 10.32.1.0/24    net.dmz.
#entry = 10.23.2.0/28
#entry = 10.32.2.0/23    net.protected.
#done

#  The entry with no prefix will simply have no prefix



[Io]
#  Ministry's network IO is asynchronous with threads that write to network,
#  to prevent blocking during time-sensitive operations.  It also has the
#  virtue that sending the same content to multiple targets becomes easy, as
#  buffers are written and then attached to IO threads to writing.  Multiple
#  targets are indepdendently tracked, with IO buffering handled separately,
#  so one unresponsive target will not prevent working ones from receiving
#  data.

#  This means that separate threads are created for each target, and they
#  will look for data to send on an interval.  This is controllable in
#  either USEC or MSEC.
#sendUsec = 11000
#  or
#sendMsec = 11

#  Ministry will pause before attempting to reconnect to a dead target, as
#  the most likely cause is either a process restart or host restart, and
#  those may not be instant.
#reconnectMsec = 2000



[Target]
#  Ministry understands a couple of different types of target, though the
#  primary type is graphite-compatible types.  Support for OpenTSDB is
#  limited.  Targets are defined as a network target, a type, and how many
#  IO buffers to hold for sending.

#  Targets are also organised into lists.  Data is not sent to single
#  targets but rather to lists.  Every target in the list gets the same
#  data.  This is code shared with carbon-copy where this functionality is
#  more relevant.  Where no list value is given, it defaults to the name,
#  making a list of 1.

#  An example target.
#name = local
#host = 10.32.6.10
#port = 2003
#type = graphite
#enable = 1
#maxWaiting = 1024
#done




[Network]
#  Network timeout sets how long a source connection has to be silent for
#  before we consider it dead and close the connection.  Don't set this too
#  low or clients will keep having to reconnect.
#  This value is in SECONDS
#timeout = 3600

#  Ministry listens for UDP packets if configured to do so, but by default
#  recv() just waits forever.  Thus we set a receive timeout value and loop
#  around in quiet times.  This value affects how responsive ministry is to
#  shutdown.  You shouldn't need to change it.  It is in SECONDS.
#rcvTmout = 3


#  Ministry can prepend fixed strings to paths received from hosts that
#  connect with TCP and are specified in config.  The strings are prepended
#  at network receive time, so later functions like synthetics will perceive
#  the updated path, not the original path.  This is done by creating a
#  prefix-style IP List and then selecting it for use here.
#prefix = <name>


#  Ministry can also enforced IP Lists for connecting clients.  An IP list
#  is created and then referenced within network config
#filterList = <name>



#  Ministry opens separate ports for communication using its own format, but
#  can also listen for statsd-compatible data.  Each can be individually
#  enabled on TCP or UDP, and their listen ports specified.

#  A note on performance.  Connecting TCP clients are hashed across a number
#  of threads designated to handle a given type of client.  Each thread has
#  a maximum number of clients it will accept at any one time.  There will
#  be a separate thread actually bound the port, listening for new clients.

#  UDP ports do not permit the same behaviour, so a single thread listens on
#  each UDP port.  To permit multiple threads to handle UDP traffic, multiple
#  ports must be specified, and the clients should load-balance themselves
#  across this.  Alternative, on Linux, Iptables may be capable of helping.
#  There is no requirement to make one client sticky to one point.

#  By default, IP whitelist/blacklist checks and path prefixing are not
#  done on UDP data as they impact performance.  This can be lit up, type
#  by type, with a specific checks options.


#  Stats - stats data, of the format "<path> <value>\n"  It is stored, and
#  every stats interval it is processed to produce stats about it.  The
#  actual data is not presented to targets - just highest, lowest, and some
#  other metrics about it.

#  Adder - summation data, for where multiple sources must have the same
#  path data added together, which graphite makes a mess of.  It is done in
#  very similar fashion to the above, and has the same format.

#  Gauge - state data, where the latest value received is presented over and
#  over to the targets.  Also updates may come in the form of
#  value -> double      this is the new value
#  value -> +double     add this to the current value
#  value -> -double     decrement this from the current value

#  This has the consequence that in order to set a new value that is negative,
#  the value must first be set to 0.  This is to retain compatibility with
#  Etsy's statsd behaviour
#  https://github.com/etsy/statsd/blob/master/docs/metric_types.md

#  Statsd - a format compliant with parts of Etsy's statsd process, in order
#  to allow processes which have that pre-built into them to talk to ministry.
#  Format "<path>:<value>|<c or ms>\n".  Some of the more complex parts of
#  statsd's behaviour are not duplicated.


#  Enable - switch on this port type
#stats.enable  = 1
#adder.enable  = 1
#gauge.enable  = 1
#compat.enable = 1

#  TCP - light up tcp ports for this type
#stats.tcp.enable  = 1
#adder.tcp.enable  = 1
#gauge.tcp.enable  = 1
#compat.tcp.enable = 1

#  UDP - light up udp ports for this type
#stats.udp.enable  = 1
#adder.udp.enable  = 1
#gauge.udp.enable  = 1
#compat.udp.enable = 1

#  UDP - do checks with ip whitelist/blacklists and do prefixing
#stats.udp.checks = 0
#adder.udp.checks = 0
#gauge.udp.checks = 0
#compat.udp.checks = 0

#  UDP port(s).  A comma-separated list of UDP ports to listen on.
#stats.udp.port  = 9125
#adder.udp.port  = 9225
#gauge.udp.port  = 9325
#compat.udp.port = 8125

#  TCP port.  (It makes no sense to have multiple TCP ports)
#stats.tcp.port  = 9125
#adder.tcp.port  = 9225
#gauge.tcp.port  = 9325
#compat.tcp.port = 8125

#  TCP bind address - which IP address to bind to.  Defaults to all.
#stats.tcp.bind  = 0.0.0.0
#adder.tcp.bind  = 0.0.0.0
#gauge.tcp.bind  = 0.0.0.0
#compat.tcp.bind = 0.0.0.0

#  TCP backlog - how many outstanding connections to queue up
#  This is limited by the value of /proc/sys/net/core/somaxconn
#stats.tcp.backlog  = 32
#adder.tcp.backlog  = 32
#gauge.tcp.backlog  = 32
#compat.tcp.backlog = 32



#  Ministry handles a *lot* of packets when it is busy.  Processing sending
#  stats values need to do so in a timely fashion, lest whatever cycles of
#  gathering and sending start to interact (usually undesirably) with the
#  reporting cycle.  Many hosts sending stats will send a line at a time, or
#  just a few together.  Given that busy metrics in some installations send
#  tens of thousands of data points per second, quite how ministry polls
#Â  many connections is very important.  Pooling and epoll show *very, very*
#  high system CPU on stats connections, and so ministry retains the ability
#  to have a thread per connection.  These are described as TCP 'styles' and
#  ministry has three:

#  thread - one thread per connection, poll on a single socket
#  pool - a thread pool is assigned connections, and they poll all the sockets
#  epoll - a thread pool is assigned connections, but uses epoll to check them

#  The recommended styles are the defaults
#stats.tcp.style = thread
#adder.tcp.style = epoll
#gauge.tcp.style = epoll
#compat.tcp.style = thread

#  Handler threads - how many separate threads run at once.  This determines
#  how many concurrent accesses to path mutexes are possible, as well as the
#  maximum number of CPUs that can be used at once.  However, that is not the
#  main factor in deciding the thread counts.  The maximum connected clients
#  is equal to threads * pollMax.  Putting too many clients on one thread
#  will lead to waiting and reduced throughput, so a high enough thread
#  count to cope with the expected number of clients with a reasonable max
#  contention is the way to calculated it:
#  threads = (max connections) / (poll max * 0.8)

#  The 0.8 is to account for hashing leading to uneven distribution of
#  connections.
#stats.tcp.threads  = 60
#adder.tcp.threads  = 30
#gauge.tcp.threads  = 10
#compat.tcp.threads = 20

#  Thread pollMax - how many clients each thread will take.  Each threads
#  has a fixed array of poll struct's, so this represents a hard limit.  If
#  connections beyond this limit are presented they will be rejected and
#  closed.  It is also notable that threads are assigned by a hashing
#  algorithm (on src-ip,src-port) and so not all slots end up in use.
#stats.tcp.pollMax = 128
#adder.tcp.pollMax = 128
#gauge.tcp.pollMax = 128
#compat.tcp.pollMax = 128


#  Tokens

#  Ministry has a feature to help secure the integrity of metric submission.
#  It is only partly built - the webserver does not have auth yet, so some
#  kind of authorising proxy in front of it would be needed for proper
#  security.

#  The feature works like this.  TCP connections expect to be provided with
#  a valid token on the first line of submission, or else the connection is
#  closed.  Clients can obtain a token by requesting /token from the web
#  server.  The tokens are returned as JSON, one for each of the types of
#  data: stats, adder, gauge.  Compat does not use it, as it is presumed
#  that clients needing compat submission actually believe they are talking
#  to Etsy's statsd.

#  Tokens, once generated, expire in a short time.  For best security,
#  fetch the tokens over HTTPS, then use them immediately.  Once seen even
#  once, the token is burned, never valid again.  Tokens are tied to the
#  IP address which made the /token request and are not valid for any other
#  IP address.
#tokens.enable = 0

#  Tokens can use an Iplist as a filter for which hosts are required to
#  use them.
#tokens.filter =

#  How long tokens last is configurable, in msec.
#tokens.lifetime = 1000


[Stats]
#  This section controls stats generation and submission

#  Thresholds are the percentage markers for reporting.  Ministry supports
#  both whole percent and per-mille values (denoted with an 'm' appended).
#  A comma-separated list will give multiple thresholds.

#  This is a comma-separated list and is not restricted to the upper half -
#  it is entirely reasonable to have values set to "10,90", for example, to
#  examine outliers.  Values above 50 are reported as upper_%d and those
#  below are reported as lower_%d.  0, 50 and 100 are not accepted - lower,
#  median and upper are reported anyway.  None are set by default, but 90,99
#  are popular choices for statsd hackers.  For the service-conscious admin,
#  perhaps 90,99,999m
#thresholds = 


#  Ministry can perform additional statistical analysis on stats paths, to
#  generate more than just mean, median and thresholds.  It can also produce
#  standard deviation, skewness and kurtosis.  These statistics are explained
#  here:

#  https://en.wikipedia.org/wiki/Standard_deviation#Estimation
#  https://en.wikipedia.org/wiki/Skewness#Sample_skewness
#  https://en.wikipedia.org/wiki/Kurtosis#Sample_kurtosis

#  This is off by default, and comes at some cost - when new stats paths are
#  encountered, they are checked to see if they should need this processing
#  and that can involve running regular expression checks against them.  To
#  turn this on globally, enable it.
#moments.enable = 0


#  Moments checking is controlled by regular expression matching of paths.  If
#  none are defined, it uses the fallback.  They are expressed as a whitelist,
#  blacklist combination and processed in order.

#  The default is none, and these are offered as an example.
#moments.whitelist = ^webserver\.apache\.
#moments.blacklist = \.returnCode\.50[1-9]\.
#moments.whitelist = \.timings\.(complete|connect)$


#  Once regular expression checking is completed, it is configurable whether no
#  matches is a pass or a fail.  That is controlled by the fallback setting.  This
#  defaults to matching (1).  Disable this to fallback to failed-to-match.
#moments.fallbackMatch = 1


#  Moments processing is also controlled by a minimum points check.  If there are
#  not many points then the values are fairly meaningless.  This defaults to 30.
#moments.minimum = 30



#  Ministry can perform prediction of adder metrics (gauges do not have a
#  predictable input frequency and stats metrics are not suitable).  It does
#  this by running linear regression on a set of recent metrics.  This means
#  it has to keep recent metrics and this is why it is not done routinely.

#  The result is a prediction for the next period's metric, along with the diff
#  of the previous prediction against the current metric, and the prediction
#  parameters (a, b, where y = a + bx) and a correlation coefficient r^2, which
#  runs from 0 to 1, with 0 being no fit, and 1 being perfect fit.  Anything
#  over 0.95 is a very good fit.

#  The only algorithm at present is linear regression.  Other algorithms, like
#  polynomial regression, may be added later.  Algorithms must have output values
#  suitable to be displayed in metrics.

#  The intended use case is to provide a rolling model of the metric concerned.
#  The predicted value and diff are merely checks on the quality of the model.
#  In these graphs, y is the metric and x is the timestamp, and the values of
#  the model parameters enable arbitrary prediction of the metric over time.

#  It suffixes a number of strings to the given path.  NOTE, if this metric
#  was previously reported, the new paths with conflict with the old path.
#  The metric, a.b.c.d, will be reported as:
#  a.b.c.d.input              the value received
#  a.b.c.d.prediction         the expected value next period
#  a.b.c.d.diff               the diff of previous-predicted - actual-input
#  a.b.c.d.fit                the correlation coefficient, 0-1, higher is better

#  the remainder are algorithm-dependent, but for linear regression, they are
#  a.b.c.d.lr_a               parameter a (the constant)
#  a.b.c.d.lr_b               parameter b (the factor for x)

#  So predicting the value at an arbitrary time in the future, timestamp T, is:
#  value = a.b.c.d.lr_a + ( T * a.b.c.d.lr_b )

#  Prediction is off by default
#predict.enable = 0

#  The number of values kept affects the memory and cpu impact of doing this
#  prediction.  The value must be 8 <= x <= 254.  Too few and the values are
#  meaningless.  Too many and the impact is too high.
#predict.size = 32

#  Regex matching is the same as with moments.  Nothing is there by default.
#predict.whitelist = <a valid path regex>
#predict.blacklist = <a valid path regex>

#  By default, it does NOT match.
#predict.fallbackMatch = 0



#  Ministry can perform mode checks on stats values, but this is somewhat
#  expensive to compute, and not meaningful for many types of stats.  So
#  it is controlled, as with moments and prediction, via a set of whitelist/
#  blacklist regular expressions applied to a path when it is first seen.
#mode.enable = 0

#  It only makes sense to provide a mode given a certain minimum number of
#  values.
#mode.minimum = 30

#  The same mechanism as for prediction and moments controls path selection.
#mode.whitelist = <valid path regex>
#mode.blacklist = <valid path regex>

#  Fallback to match or not
#mode.fallbackMatch = 0




#  Then the rest come in two types, stats and adder.  These are differently
#  (and, I admit, a little confusingly) named to the network ports, but those
#  relate to incoming format, and both stats and statsd|ms go to stats, and
#  adder and statsd|c go to adder.  So these now relate to outgoing data,
#  one being summed metrics, the other being metadata about input values.
#  There is a third category - self.  Ministry reports some stats about
#  itself (not many yet, more will be coming at some point).


#  Enable or disable for each type - does what it sounds like
#stats.enable = 1
#adder.enable = 1
#gauge.enable = 1
#self.enable = 1



#  Prefix - path elements to prepend to all metrics.  Etsy's statsd prepends
#  'stats.timers.' to all stats metrics by default.  This is duplicated in
#  ministry because it was intended as a drop-in replacement (with options
#  to use it's preferred formats when possible) and moving metrics around in
#  graphite is a real pain.  Won't somebody think of the dashboards?  So the
#  old behaviour is supported.

#  Adder and gauge are intended to be transparent so have no default prefix,
#  and ministry's own stats are tucked away inside self.ministry.  Ministry
#  will add a . to the end of the prefix if it's non-zero length and you forgot.

#stats.prefix = stats.timers.
#self.prefix  = self.ministry.

#  Only uncomment these if you are setting a string - an empty value will
#  become "1"
#gauge.prefix =
#adder.prefix =


#  Ministry creates a set number of threads to do stats/adder processing.
#  Adder might happily run on just 1 or 2, but stats calculations include a
#  qsort() to get all those fixed thresholds and that chews CPU.  So a larger
#  number is useful.  If you find it is chewing too much CPU every stats
#  period, tune this down a little.  It will only slightly affect the accuracy
#  of the time windowing.

#  Ministry's processing threads first pass across the DHASH table, 'stealing'
#  the data to be processed - a DHASH structure contains both an incoming and
#  a processing location for data, and the data is moved from incoming to
#  processing first.  Only once this is complete does ministry go back and
#  process the data it stole - this means ministry's concept of 10 seconds
#  worth of data is pretty precise.  The pass across the whole table to do
#  the steal is sub-millisecond with 20,000 paths, and is deterministic - it
#  passes across the table in the same order every time.

#stats.threads = 6
#adder.threads = 2
#gauge.threads = 2
#self.threads  = 1



#  Ministry has a global setting for hash table size which becomes the default
#  for each of the different types (self does not use such a table).  However,
#  they can each be given a specific table size, or using a number of words to
#  choose from pre-configured values.  The words are:

#  tiny    => 1009
#  small   => 5003
#  medium  => 25013
#  large   => 100003 (same as the default mem.hashsize)
#  xlarge  => 425071
#  x2large => 1300021

#  As hash tables use memory, and take time to spider across, having them at
#  about the right size has performance advantages.  Having them too small is
#  not fatal, but does cause performance to deteriorate.  They need scaling
#  to be probably not less than a quarter of the expected number of data paths
#  of the given type, and the ideal is about the same.  However, they can be
#  set directly, by having a numeric argument rather than a word.  A note of
#  caution though - ministry uses a very efficient hash algorithm, provided
#  the hash size is not a power of two.  It does no bit mixing - it expects
#  a prime number hash size.  So a prime number will avoid certain degenerate
#  performance cases, and is highly recommended.

#  Note!  Stats values such as .count, .upper, etc etc are not part of them
#  hash table - they are generated.  So count the layer below.  It is the paths
#  as submitted that are counted.

#  They all default to a hash size of -1, which results in the global hashsize
#  value being used, so if you want to set them all, set that.  However, most
#  installations will have varying proportions of each, and this data can be
#  gleaned from ministry's own self reporting, where the number of paths, and
#  the hash ratios, are reported.  Below is, rather than the defaults, some
#  example settings.
#stats.size = medium
#adder.size = large
#gauge.size = tiny



#  Ministry's loop control has the option to synchronise to a clock, so that
#  a 10-second period will result in stats collection at minute:00, minute:10,
#  etc etc.  Stats collection and adder collection thus happens precisely on
#  the period marker.  This means that if a client submits data in or around
#  the period marker is may oscillate back and forth between which time
#  bucket it submits in.  If this is happening in your estate (look for
#  oscillating data that you expected to be stable) then you can set an offset
#  in stats collection to allow for this.

#  An example.  You have some processes that submit metrics every 2 seconds
#  which include some you want adding up.  They submit on or around the 2
#  second mark, but may well submit up to 30msec late.  Rather than have the
#  data in those late submission count against the *next* period, offset the
#  calculation a little to catch them.  In this example, anything up to 2
#  seconds should be fine - apps are less often early.  But to account for
#  clock drift and the vaguaries of VMs and such, an offset of 400msec might
#  see all submissions going where they belong.
#
#  This value is in MSEC
#stats.offset = 0
#adder.offset = 0
#gauge.offset = 0


#  The last thing - submission period (or interval).  This is how often
#  ministry submits stats onwards.  The default is 10 seconds, or rather
#  10000 msec.  Ministry will sync to the clock time to enact this, so if you
#  specify 10 seconds, it will be on the :00, :10, :20, second boundaries.
#  When shut down, ministry will wait to submit the data it has got, so it
#  may take up to one period to shut down.

#  There is no requirement to keep your submission periods the same between
#  adder and stats, but experience suggests you should, if only for the sake
#  of graphs that include both data.

#  Reducing the submission period to 1 second works fine, but be advised that
#  that is the lower limit of graphite resolution.
#
#  This value is in MSEC
#stats.period = 10000
#adder.period = 10000
#gauge.period = 10000


[Synth]
#  Synthetic Metrics

#  Synthetics are metrics derived from submitted metrics, but which are not
#  directly provided by a source.  For example:

#  Suppose two metrics are supplied by a source, total requests lamp.requests
#  and customer purchases, user.purchases
#
#  To watch for anomalies in either metric is hard, because of the sheer
#  variability in each metric over time.  However, customers may well have a
#  fairly stable set of paths to making a purchase, so the ratio of the two is
#  a more useful metric.
#
#  This metric could be generated a fetch time from whatever time-series DB
#  things end up in, but it may make sense to keep the metric separately (if
#  you alert on it, for example).

#  So what's needed is the ability to divide the number of requests by the
#  number of purchases.  This is accomplished by creating a synthetic metric
#  from those two, dividing lamp.requests by user.purchases.  Ministry will
#  do this at metric calculation time.
#
# target = lamp.requests_per_purchase
# source = lamp.requests
# source = user.purchases
# operation = ratio
# factor = 1
# done

#  Then, along with submitting onward a value for each of the two source
#  metrics, ministry will submit the calculated metric.  There is no difference
#  in how they are presented downstream.

#  By default, no synthetic metrics are defined.  Each synthetic must have a
#  target path, a number of sources, and operation, and each must be marked
#  'done' to complete it.  Basic error checking is done to make sure a config
#  block defining a synthetic has everything it must have (all operations have
#  a minimum number of parts).

#  Only ADDER metrics are supported for synthetic processing.  The stats end
#  metrics (.count, .mean, etc) don't really exist in ministry's memory and in
#  any case are not directly submitted metrics.


#  Target metric should not be submitted to directly - submissions to it are
#  ignored.
#target = my.synthetic.metric

#  Source metrics obviously won't exist when ministry starts up, so error
#  checking to see that they exist is obviously not possible.  It an expected
#  synthetic is not showing up, check all of it's component sources are being
#  submitted at the same time.
#
#  The maximum number of sources per synthetic is 32.
#source = source.metric.first
#source = source.metric.second
#...


#  The factor value is applied to the calculated result.  It's purpose is to
#  allow percent calculations, etc etc.  It defaults to 1 if not supplied.
#  factor = 1

#  The supported operations are:
#  Name      Min Parts      Description
#  sum       1              Sum up all sources
#  diff      2              Source 2 subtracted from source 1
#  ratio     2              Source 1 divided by source 2 (if != 0)
#  cap       2              Highest of 2 (set or not)
#  max       1              Highest value amongst all sources
#  min       1              Lowest value amongst all sources
#  spread    1              Gap between highest and lowest values
#  mean      1              Mean of all paths provided
#  meanIf    1              Mean of all paths provided that had values
#  count     1              Count of non-zero values
#  active    1              Set to 1 if we *have* the metrics specified




#  This is included to make the container work out of the box, allowing a
#  file to be added, configMap'd in, and override anything and add targets
include = ?/etc/ministry/ministry-extra.conf

